use std::sync::Arc;\nuse uuid::Uuid;\nuse chrono::Utc;\nuse olympus_shared::database::Database;\nuse olympus_shared::types::Money;\nuse crate::models::{Payment, PaymentRequest, PaymentStatus, PaymentMethod};\n\npub struct PaymentService {\n    _db: Arc<Database>,\n}\n\nimpl PaymentService {\n    pub fn new(db: Arc<Database>) -> Self {\n        Self { _db: db }\n    }\n\n    pub async fn process_payment(&self, request: PaymentRequest) -> Result<Payment, String> {\n        // Validate payment request\n        if request.amount.amount <= 0 {\n            return Err(\"Payment amount must be positive\".to_string());\n        }\n\n        // Create payment record\n        let payment = Payment {\n            id: Uuid::new_v4(),\n            order_id: request.order_id,\n            amount: request.amount,\n            method: request.method,\n            status: PaymentStatus::Processing,\n            gateway_transaction_id: None,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        };\n\n        // Process based on payment method\n        match request.method {\n            PaymentMethod::Cash => self.process_cash_payment(payment).await,\n            PaymentMethod::Card => self.process_card_payment(payment, request.card_token).await,\n            PaymentMethod::Wallet => self.process_wallet_payment(payment).await,\n        }\n    }\n\n    async fn process_cash_payment(&self, mut payment: Payment) -> Result<Payment, String> {\n        // Cash payments are immediately captured\n        payment.status = PaymentStatus::Captured;\n        payment.updated_at = Utc::now();\n        Ok(payment)\n    }\n\n    async fn process_card_payment(&self, mut payment: Payment, card_token: Option<String>) -> Result<Payment, String> {\n        if card_token.is_none() {\n            return Err(\"Card token required for card payments\".to_string());\n        }\n\n        // Simulate card processing\n        payment.gateway_transaction_id = Some(format!(\"txn_{}\", Uuid::new_v4().to_string()[..8]));\n        payment.status = PaymentStatus::Captured;\n        payment.updated_at = Utc::now();\n        Ok(payment)\n    }\n\n    async fn process_wallet_payment(&self, mut payment: Payment) -> Result<Payment, String> {\n        // Simulate wallet processing\n        payment.gateway_transaction_id = Some(format!(\"wallet_{}\", Uuid::new_v4().to_string()[..8]));\n        payment.status = PaymentStatus::Captured;\n        payment.updated_at = Utc::now();\n        Ok(payment)\n    }\n\n    pub async fn refund_payment(&self, payment_id: Uuid, amount: Money) -> Result<Payment, String> {\n        // Create refund record\n        let refund = Payment {\n            id: Uuid::new_v4(),\n            order_id: Uuid::new_v4(), // Would be linked to original payment\n            amount: Money::new(-amount.amount, amount.currency), // Negative for refund\n            method: PaymentMethod::Card, // Would match original\n            status: PaymentStatus::Refunded,\n            gateway_transaction_id: Some(format!(\"refund_{}\", payment_id.to_string()[..8])),\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        };\n        Ok(refund)\n    }\n\n    pub async fn get_payment(&self, payment_id: Uuid) -> Result<Payment, String> {\n        Ok(Payment {\n            id: payment_id,\n            order_id: Uuid::new_v4(),\n            amount: Money::new(2500, olympus_shared::types::Currency::USD),\n            method: PaymentMethod::Card,\n            status: PaymentStatus::Captured,\n            gateway_transaction_id: Some(\"txn_12345678\".to_string()),\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        })\n    }\n}